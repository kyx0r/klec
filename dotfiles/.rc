#!/bin/sh
export ENVSET=1
export EXINIT="$(printf '%b' 'led:ish:      1io{\n}kA\n	\x1b:1,3;0;$yaq:        1iA {jo}koa\x1b:;0;$yaw:     1i\\:e \!p $c\x1b:;0;$yae:     1iI/*A*/\x1b:;0;$yaa:     1ii/*A*/\x1b:;0;$yas:      1i/\/\*\n2x/\*\/\n2x\x1b:1,3;0;$yad:     1i>\%<<$\%<<\x1b:;0;$yax:     1i\\:\!cp \% \%_\\:w\\:\!git diff --no-index \%_ \%\x1b:;0;$yal:      1i\\:cd \!p $c\x1b:;0;$yaf:       1i\\:ph1 1 2 1^A\\:ph2 2 2 1^B\\:ph3 3 2 1^C\\:ph4 4 2 1^D\\:ph5 5 2 1^E\\:ph6 6 2 1^F\\:ph7 7 2 1^G\\:ph8 8 2 1^H\\:ph9 9 2 1^I\\:ph10 10 2 1^J\\:ph11 11 2 1^K\\:ph12 12 2 1^L\\:ph13 13 2 1^M\\:ph14 14 2 1^N\\:ph15 15 2 1^O\\:ph16 16 2 1^P\\:ph17 17 2 1^Q\\:ph18 18 2 1^R\\:ph19 19 2 1^S\\:ph20 20 2 1^T\\:ph21 21 2 1^U\\:ph22 22 2 1^V\\:ph23 23 2 1^W\\:ph24 24 2 1^X\\:ph25 25 2 1^Y\\:ph26 26 2 1^Z\\:ph27 27 2 1^[\\:ph28 28 2 1^\\\\\\:ph29 29 2 1^]\\:ph30 30 2 1^^\\:ph31 31 2 1^_\x1b:;0;$yaz:         inc (^(?\:(?\!^\.git).)+[^/]+$):u:pac:led')"
export HISTFILESIZE=1073741824
export HISTSIZE=67108864
export KISS_SU=su
export KISS_PATH=
KISS_PATH="$HOME/kiss/no-updates"
KISS_PATH="${KISS_PATH}:$HOME/kiss/repo-main/core"
KISS_PATH="${KISS_PATH}:$HOME/kiss/repo-main/extra"
KISS_PATH="${KISS_PATH}:$HOME/kiss/repo-main/xorg"
KISS_PATH="${KISS_PATH}:$HOME/kiss/repo-main/community"
export CHROME_FLAGS="--no-sandbox"
export XDG_RUNTIME_DIR=/tmp
export PATH="$HOME"/klec/shell:"$PATH"
export EDITOR=vi
export HOST_PS1="\[\e[1;33m\]$(printf '%.1s%s' "$HOSTNAME" "${HOSTNAME#"${HOSTNAME%?}"}")\[\e[m\]"
export PS1="$HOST_PS1\[\e[1;32m\]\w\[\e[m\] "
export CFLAGS="-O2"
export KCFLAGS="$CFLAGS"
export CXXFLAGS="$CFLAGS"
export KCPPFLAGS="$CFLAGS"
export NCORES="$(grep -c "^processor" /proc/cpuinfo)"
export MAKEFLAGS="-j$NCORES"
export PREFIX=/usr
export DISPLAY=:2
export FDMAXLEN0=0
export FDMAXLEN1=0
export FDCOUNT=0
export FDTRIM=0

# git
alias g='git'
alias ga='git add'
alias gal='git add .'
alias gb='git branch'
alias gbd='git push origin --delete'
alias gc='git commit'
alias gca='git commit --author'
alias gcm='git commit -m'
alias gcms='git commit -S -m'
alias gco='git checkout'
alias gd='git diff'
alias gds='git diff --staged'
alias gdi='git diff --no-index'
alias gl='git log --graph --oneline'
alias glg="git log --graph --decorate --stat"
alias glf='git log --follow --'
alias gp='git push'
alias gpf='git push --force'
alias gpd='git push origin --delete'
alias gpl='git pull'
alias gs='git status'
alias ge='git config user.email'
alias gsh='git stash'
alias grh='git reset --hard'
alias gr='git restore'
alias grs='git reset'
alias gcl='git clean'
alias gclf='git clean -f'
alias gcls='echo "Add -f to remove dirs with .git" && git clean -fxd'
alias gru='git remote update'
alias grv='git remote -v'
alias gurl='git remote get-url --push origin'
alias gpurl='git remote set-url --push origin'
alias gurls='git remote get-url --all origin'
alias gra='git remote add'
alias gcp='g cherry-pick'
alias gcn='g cherry-pick --continue'
alias gca='g cherry-pick --abort'
alias gfp='git format-patch'
alias gam='git am'
alias gt='git tag'
alias gpt='git push origin tag'
alias gmnd='git commit --amend'
gcom() {
	if git show-ref --verify --quiet refs/heads/main; then
		git checkout main
	else
		git checkout master
	fi
}
gdf() {
	hist="$(git --no-pager log --follow "$1" | grep -E '^commit' | cut -d' ' -f2)"
	IFS="
"
	prev=""
	mkfifo /tmp/pipe
	for p in $hist; do
		if [ -n "$prev" ]; then
			echo
			echo "Commit: $prev -> $p"
			echo "Msg: $(git log -1 --pretty=%B "$prev")"
			echo "Date: $(git log -1 --pretty=format:%cd --date=format:'%Y-%m-%d %H:%M' "$prev")"
			echo
			git --no-pager diff "$p" "$prev" --follow "$1"
		else
			sleep 0.1
		fi
		prev=$p
	done > /tmp/pipe &
	cat /tmp/pipe | less
	rm /tmp/pipe
}
gdh() { git diff HEAD~"$1"; }
gap() { for arg in "$@"; do git apply -3 < "$arg"; done; }
grsr() { git reset "$1" && rm "$1"; }
gct() { git checkout tags/"$1"; }
gfork() { git remote add fork "$1" && git fetch fork && git merge fork/"$2"; }
grt() { git reset HEAD~"$1"; }
gcop() {
	first="$1"; shift;
	for var in "$@"
	do
		git checkout "$first" -- "$var"
	done
}
gcr() {
	git clone --recursive "$@"
	if [ $# -eq 1 ]; then
		cd "$(echo "$1" | sed 's/.*\///' | sed 's/.git$//')" || return
	fi
}
gcb() {
	git clone --single-branch "$@"
	if [ $# -eq 1 ]; then
		cd "$(echo "$1" | sed 's/.*\///' | sed 's/.git$//')" || return
	fi
}
gtossh() {
	curl=$(git remote get-url --push origin);
	echo "git@$(echo "$curl" | cut -d '/' -f 3):$(echo "$curl" | grep -E -o '[^/]*.[^/]*$')";
}
gcmf() {
	ln=$2
	[ -z "$ln" ] && ln=1
	git commit -m "$(git diff --name-only --cached | sed -n "${ln}p" | tr '\n' ':') $1"
}
gcmfe() { gcmf "$@"; git commit --amend; }
gcmd() {
	ln=$2
	[ -z "$ln" ] && ln=1
	name="$(git diff --name-only --cached --relative | sed -n "${ln}p" | cut -d'/' -f1)"
	[ ! -d "$name" ] && name="$(basename "$PWD")"
	git commit -m "$(echo "$name" | tr '\n' ':') $1"
}
gcmde() { gcmf "$@"; git commit --amend; }
gcmfs() {
	MSG=""
	ffor "$(git diff --name-only --cached | sed -n "$2p")"\
	"printf '%s: '" "; read i; MSG=\$(printf '%b\n' \"\$MSG\\n\$p: \$i\")"
	git commit -m "$1
$MSG"
}
gpfix() { gal; gds > "$1"; grs; ga "$1"; if [ "$2" ]; then gcmf "$2"; else gcmf "fix"; fi; grh; }
gtd() { git tag --delete "$1"; echo "delete tag at origin?" && read resp; git push --delete origin "$1"; }

# alpine linux
alias apka='apk add'
alias apkd='apk del'
alias apks='apk search'
alias apkl='apk list -I|less'
alias apkll='apk list|less'
alias apkm='apk manifest'

# arch linux
alias pac='pacman'
alias pacfs='pacman -Fx'
alias pacs='pacman -Ss'
alias pacu='pacman -Syyu'
alias paci='pacman -Qi'
alias pacl='pacman -Ql'
alias pacq='pacman -Q'
alias pc='rm /var/lib/pacman/db.lck'
alias mpkg='makepkg -si --skippgpcheck --skipinteg --skipchecksums'

# kiss linux
alias k='kiss'
alias kc='kiss-chroot'
alias kd='export KISS_DEBUG=1'
alias kdu='unset KISS_DEBUG'
alias kds='export KISS_STRIP=0'
alias km='kiss manifest'
alias krv='kiss revdepends'
alias kdp='kiss depends'
krepo() { echo 'export KISS_PATH="$KISS_PATH:'"$(fullpath $*)\"" >> "$HOME"/.lrc; }
kow() { kiss owns /bin/"$1"; }
kpc() {
	dirs=$(ls "$HOME"/.cache/kiss/proc/*/build/)
	echo "$dirs" | tr '\n' ' ' | sed "s/  /\n/g" ; echo
	if [ "$2" ]; then
		cd "$HOME"/.cache/kiss/proc/"$2"*/build/"$1"* || return
	else
		cd "$HOME"/.cache/kiss/proc/*/build/"$1"* || return
	fi
}
kpr() { rm -rf "$HOME"/.cache/kiss/proc/*; }
knu() { mkdir -p "$HOME"/kiss/no-updates && cp -r /var/db/kiss/installed/"$1" "$HOME"/kiss/no-updates; }
kru() { rm -Rf "$HOME"/kiss/no-updates/"$1"; }
ki() { export KISS_PROMPT=0 && kiss b "$1" && kiss i "$1" && unset KISS_PROMPT; }
kci() { rm "$HOME"/.cache/kiss/bin/"$1"* && ki "$1"; }
kcd() { path=$(kiss search "${1}*"); [ $? -eq 0 ] && cd "$(echo "$path"|head -n1)" || return; }
krs() { export KISS_FORCE=1; for file in "$@"; do kiss r "$file"; done; unset KISS_FORCE; }
kcmv() {
	dir=$(dirname "$(git diff --name-only --cached --relative | head -n1)")
	[ "$dir" = "." ] && dir="$PWD"
	git commit -m "$(basename "$dir"): $(cat "$dir"/version)"
}
kcm() {
	dir=$(dirname "$(git diff --name-only --cached --relative | head -n1)")
	[ "$dir" = "." ] && dir="$PWD"
	git commit -m "$(basename "$dir"): $*"
}

# make
alias m='make'
alias mi='make install'
alias mc='make clean'
alias mu='make uninstall'

# networking crap
alias rn='route -n'
alias ipn='ip -brief neigh show'
alias lsnet='netstat -tulpn'
alias wip='ipconfig'
alias wipr='ipconfig //renew'
alias td='tcpdump'
alias ipv='iptables -L -v -n'
ipa() { ip a add "$1" dev "$2"; }
ipd() { ip a del "$1" dev "$2"; }
ipra() { ip route add "$1" via "${1%.*}.$((${1##*.}+1))" dev "$2"; }
iprd() { ip route del "$1"; }

# ffmpeg
tomp4() { ffmpeg -i "$1" -vcodec libx265 -crf 28 "${1%.*}.mp4"; }
fftrim() { ffmpeg -accurate_seek -i "$1" -to "$2" -c:v copy -c:a copy "$(funiq "$1")"; }
fframe() { ffmpeg -i "$1" -vf fps=1/5 '%04d.png'; }
fframe1() { ffmpeg -i "$1" -vframes:v 1 "${1%.*}.png"; }
chfps() { ffmpeg -y -i "$1" -vf "setpts=1.25*PTS" -r "$2" "$(funiq "$1")"; } # x > 1 slow down, x < 1 speed up
nullasrc() { ffmpeg -i "$1" -f lavfi -i anullsrc=channel_layout=stereo:sample_rate=48000 -c:v copy -shortest "$(funiq "$1")"; }
ffchk() { ffmpeg -loglevel verbose -i "$1" -map 0:a -f null -; }
ffsp() { ffplay -ast "$2" -vf "subtitles='$1':si=$3:fontsdir=/usr/share/fonts" "$1"; }

# random progs
alias tzutc0='echo "UTC0" > /etc/timezone && cp /usr/share/zoneinfo/UTC /etc/localtime'
alias unmute='amixer sset Master unmute && amixer set Master 50%'
alias zdel='find . -size 0 -print -delete'
alias llm='source prompts.sh'
alias date='date +"%Y-%m-%d %H:%M:%S"'
alias sha='sha256sum'
alias reset='stty sane && reset'
alias re='grep -i --color=auto'
alias lre='ls -glhaS | grep -i --color=auto'
alias ls='ls --color=auto'
alias l='ls -glhaS'
alias lt='ls -glhat'
alias i='vi'
alias df='df -h'
alias cp='cp -r'
alias rm='rm -rf'
alias s='su -l'
alias feh='feh --title %f___[%wX%h]_[%u/%l] -p'
alias da='gdb --args'
alias rd='r2 -A -d -e dbg.bpinmaps=false -e bin.relocs.apply=true'
alias fdmesg='dmesg -w | tee f'
alias de='dmesg'
alias c='cd ..'
alias d='cd'
alias thw='hwclock --systohc'
alias va='valgrind --log-file=valog'
alias cgr='valgrind --tool=callgrind'
alias tmd='mount -o size=256G,noatime -t tmpfs tmpfs'
alias b='./*build.sh build && ./*build.sh install'
alias rc='source $HOME/.rc'
alias xo='xclip -selection clipboard'
alias xp='xclip -selection clipboard -o'
alias xsleep='xset dpms force standby'
alias wp='waypaste'
alias wo='waycopy'
alias gmk='grub-mkconfig -o /boot/grub/grub.cfg'
alias gin='grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB'
alias mdl='yt-dlp -x --audio-quality 0'
alias psa='ps aux'
alias psx='ps aux | grep'
alias ptrace='strace -p'
alias virtm='virt-viewer -f --hotkeys=toggle-fullscreen=shift+f11,release-cursor=shift+f12'
alias j='jobs'
i=1; while [ $i -le 10 ]; do alias "$i"="fg %$i"; i=$((i+1)); done;
alias q='fg'
alias me='ssh kyryl.me'
alias dl='curl -O'
alias dlh='curl -L -O'
alias fs='stat'
alias ctl='systemctl'
alias pyenv='python -m venv .env'
alias pyact='source .env/bin/activate'
alias uex='unset EXINIT'
alias delsyms='find . -type l ! -exec test -e {} \; -delete'

fnd() { find . -regex ".*$*.*"; }
rel() {
	if [ "$2" ]; then
		EXINIT="b-2:inc $2:fd $1:%p:q" vi -esm
	else
		EXINIT="b-2:fd $1:%p:q" vi -esm
	fi
}
se() {
	bf=1; [ $# -ge 2 ] && bf=0
	CMD="$(printf '%b' 'led:inc $1:fd:b-2:pra:1,$+1=1p:pr:bx %@a:ya!a:g/^/;;\$ya a\:e \%@a\:b-2:b-1:u:bs1:b0:b$bf:led:mpt0')"
	eval "ex=\"$CMD\""
	shift; EXINIT="$ex:$EXINIT" vi "$@"
}
cap() { file=$1; shift; script "$file" -c "$SHELL -i -c \"$*\""; sed -i 's/\r$//' "$file"; }
dedup() { cat -n "$1" | sort -u -k2,7 | sort -n | sed 's/[^\t]*.//'; }
sdedup() { grep -v '^$' "$1" | sort -u > "$1".tmp && mv "$1.tmp" "$1"; }
trace() { strace -p "$(pidof "$@")"; }
pk() { kill "$2" $(ps ax | awk "/$1/ {print \$1}"); }
args() { ps -o args= $(pidof "$@"); }
prepend() { (echo "$1"; cat "$2") > temp && mv temp "$2"; }
fappend() { mv "$1" "${2}${1}"; }
fdate() { case $1 in *.*) mv "$1" "${1%%.*}_$(date '+%Y-%m-%d').${1#*.}"; ;; *) mv "$1" "$1_$(date '+%Y-%m-%d')"; ;; esac; }
fcat() { printf '%b%s%b' "cat <<\\\\EOF > $1\n" "$(cat "$1")" "\nEOF\n"; }
randmac() { ip link set dev "$1" address "$(openssl rand -hex 6 | sed 's/\(..\)/\1:/g; s/:$//')"; }
enc() { openssl enc -aes-256-cbc -pbkdf2 -iter 20000 -in "$1" -out "$1.enc"; }
dec() { openssl enc -d -aes-256-cbc -pbkdf2 -iter 20000 -in "$1"; }
theme() { echo 'if [ -z "${THEMESET}" ]; then base16-pulsar.sh; export THEMESET=1; fi;' >> "$HOME"/.lrc; }
nrstr() { filename="$1"; echo "${filename}" | awk '{print tolower($0)}'; }
nrfile() { mv "$1" "$(nrstr "$1")"; }
neq() { echo "-$(seq -s ' -' "$@")"; }
nopw() { [ "$1" ] && passwd -d "$@" && return; passwd -d "$(id -nu)"; }
gpass() { tr -dc 'A-Za-z0-9' < /dev/urandom | head -c 12; }
path() { export PATH="$1:$PATH"; }
crop() { magick "$1" -crop "$2" "_$1"; }
imgs() { magick "$1" -strip -quality "$2" "_$1"; }
ntmount() { ntfs-3g -o uid=1000,gid=1000,dmask=22,fmask=133 "$@"; }
sof() { scp -r "$1" root@kyryl.me:"$2"; } #of = upload
sif() { scp -r root@kyryl.me:"$*"; } #if = download
scat() { cat ~/.ssh/id_rsa.pub | ssh "$1" 'cat >> .ssh/authorized_keys'; }
e() { echo "$@"; }
p() { printf "$@"; }
# ffor() usage: ffor "path/any string" "cmd" "extra opts"
ffor() { IFS="
"; i=0; for p in $1; do eval "$2 \$p $3"; i=$((i + 1)); done }
inf() { quit=0; while [ $quit -eq 0 ]; do trap 'quit=1' INT EXIT HUP TERM QUIT; eval "$1"; done }
sd() {
	reg=".*$1[^\/]*$"; if [ "$2" ]; then reg=".*$1"; fi
	dir=$(find . -type d -regex "$reg"); echo "$dir"  | grep -n -E . && read -r i
	[ -z "$i" ] && i=1
	cd "$(echo "$dir" | sed -n "$i"p)" || return
}
fup() { curl -F"file=@$1" https://0x0.st/; }
r() { grep -n -r "$@" . ; }
calc() { exp=$(echo "$*" | sed 's/\[/\(/g; s/\]/\)/g; s/x/\*/g'); echo $((exp)); }
rnm() { arg="$1"; shift; ffor "$(ls)" mv '$(echo $p | sed "$arg")'; }
cdls() {
	export PS1="$HOST_PS1\[\e[1;32m\]\w\[\e[m\] "
	\cd "$@" && l;
}
cdlsn() {
	case $CDSTACK in *"c$1"|*"c$1"c*) true;; *) export CDSTACK="${CDSTACK}c$1" ;; esac
	export PS1="$HOST_PS1\[\e[1;35m\]$1\[\e[1;32m\]\w\[\e[m\] "
	\cd "$2" && l;
}
fullpath() {
	f=$1;
	if [ -d "$f" ]; then
		base="";
		dir="$f";
	else
		base="/$(basename "$f")";
		dir=$(dirname "$f");
	fi;
	dir=$(\cd "$dir" && pwd);
	echo "$dir$base"
}
replace() {
	tmp="$1_"
	head -n "$(($2 - 1))" "$1" > "$tmp"
	echo "$3" >> "$tmp"
	tail -n "+$(($2 + 1))" "$1" >> "$tmp"
	mv "$tmp" "$1"
}
alias cd='cdls'
alias vv='cd -'
alias csc='unset CDSTACK'
cdsplit() {
	old_ifs=$IFS
	IFS=c
	set -- $CDSTACK
	IFS=$old_ifs
	first="$2"
	for last; do true; done
}
gg() {
	[ -z "$CDSTACK" ] && return
	cdsplit
	eval "var=\$c${last}"
	case $PWD in "$var") CDSTACK="c${last}${CDSTACK%c"${last}"}"; cdsplit; ;; esac
	eval "var=\$c${last}"
	export CDSTACK="c${last}${CDSTACK%c"${last}"}"
	\cd "$var" || return
	export PS1="$HOST_PS1\[\e[1;35m\]$last\[\e[1;32m\]\w\[\e[m\] "
}
bb() {
	[ -z "$CDSTACK" ] && return
	cdsplit
	eval "var=\$c${first}"
	case $PWD in "$var") CDSTACK="${CDSTACK##c"${first}"}c${first}"; cdsplit; ;; esac
	eval "var=\$c${first}"
	export CDSTACK="${CDSTACK##c"${first}"}c${first}"
	\cd "$var" || return
	export PS1="$HOST_PS1\[\e[1;35m\]$first\[\e[1;32m\]\w\[\e[m\] "
}
fd() {
	sarg=""
	if [ "$1" ]; then
		case $1 in
			''|*[!0-9-]*)
				sarg="$(fullpath "$1")"
			;;
			*)
				for arg in "$@"; do
					if [ "$arg" -lt 0 ]; then
						cnt=${arg#-}
						echo "$(sed "$((cnt - 9))s/.*//" "$HOME/links")" > "$HOME/links"
					else
						sarg="$(pwd)"
					fi
				done
				if [ "$1" -lt 0 ]; then fd; return; fi
			;;
		esac
	fi
	[ $# -ge 1 ] && shift;
	cnt=9
	maxln=-1
	maxnm=-1
	[ "$CDSTACK" ] && [ -z "$sarg" ] && echo "$CDSTACK"
	while IFS= read -r line || [ -n "$line" ]; do
		cnt=$((cnt+1))
		if [ "$sarg" ]; then
			if [ -z "$line" ]; then
				case $sarg in *[[:space:]]*) sarg="\"$sarg\"" ;; esac
				line="$sarg | $*"
				replace "$HOME/links" $((cnt - 9)) "$line" && fd
				return
			fi
			continue
		fi
		[ -z "$line" ] && continue
		p=${line%% | *}
		cmd="${line#"$p | "}"
		eval "export c${cnt}=$p"
		eval "var=\"$cmd\""
		alias "$cnt"="$var"
		p=${p#${p%%[![:space:]]*}}
		p=${p%${p##*[![:space:]]}}
		plast="${p##*/}"
		[ $FDCOUNT -gt 0 ] && fdc=$((FDCOUNT - ${#cnt})) || fdc=0
		[ $((${#plast} + ${#cnt} + fdc)) -gt $FDMAXLEN1 ]\
			&& FDMAXLEN1="$((${#plast} + ${#cnt} + fdc))" && maxnm=$cnt;
		if  [ $FDTRIM -ne 0 ]; then
			p="$plast"
			if [ $((${#p} + ${#cnt} + fdc)) -gt $FDTRIM ]; then
				p="$(echo "$p" | cut -c "$((${#p} - $((FDTRIM - ${#cnt} - fdc)) + 1))-${#p}")"
			fi
			[ $FDMAXLEN1 -gt $FDTRIM ] && FDMAXLEN1=$FDTRIM
			x=$((FDMAXLEN1 - $((${#p} + ${#cnt} + fdc))))
		else
			[ $((${#p} + ${#cnt} + fdc)) -gt $FDMAXLEN0 ]\
				&& FDMAXLEN0="$((${#p} + ${#cnt} + fdc))" && maxln=$cnt;
			x=$((FDMAXLEN0 - $((${#p} + ${#cnt} + fdc))))
		fi
		printf "%*s$cnt $p%*s | $cmd\n" $fdc "" $x ""
	done < "$HOME/links"
	FDCOUNT=${#cnt}
	[ $maxln -ge 0 ] && FDMAXLEN0="$((FDMAXLEN0 + FDCOUNT - ${#maxln}))";
	[ $maxnm -ge 0 ] && FDMAXLEN1="$((FDMAXLEN1 + FDCOUNT - ${#maxnm}))";
	if [ "$sarg" ]; then
		case $sarg in *[[:space:]]*) sarg="\"$sarg\"" ;; esac
		echo "$sarg | $*" >> "$HOME/links" && fd;
	fi
}
f() { FDTRIM=50; if [ "$1" ]; then fd "$@"; else fd; fi; FDTRIM=0; }
fe() {
	cmd="$(f | grep -i -E "$1")"
IFS="
"
	i=1; for p in $cmd; do
		printf "$i $p\n"
		i=$((i + 1))
	done 
	if [ $i -gt 2 ]; then
		read -r i
		[ -z "$i" ] && i=1
		cmd="$(echo "$cmd" | sed -n "$i"p | grep -E -o '^[ 0-9]+')"
	else
		cmd="$(echo "$cmd" | grep -E -o '^[ 0-9]+')"
	fi
	eval "$cmd"
}
ff() { arg=$1; [ ! "$arg" ] && arg="$PWD"; if [ -d "$arg" ]; then fd "$arg" 'cdlsn $cnt $p' | grep "$arg"; else fd "$arg" 'vi $p' | grep "$arg"; fi }
frm() { [ $# -ge 2 ] && fd $(neq "$@"); }
ii() { [ "$1" ] && if ! grep -q -e "$1" "$HOME/links"; then fd "$1" 'vi $p' > /dev/null 2>&1; fi; vi "$@"; }
x() { EXINIT="${EXINIT}:fd" vi "$@"; }
ix() { EXINIT='' vi "$@"; }
ic() { eval "var=$'$1'"; shift; EXINIT="$var" vi "$@"; }

funiq() {
	full_name=$(fullpath "$1")
	base_name="${full_name%.*}"
	file_ext=".${full_name##*.}"
	if [ "$file_ext" = ".$full_name" ]; then file_ext=""; fi
	count=1
	while [ -f "$base_name${count}${file_ext}" ]; do
		count=$((count+1))
	done
	echo "$base_name${count}${file_ext}"
}

compr() {
	FILE=$1
	shift
	case $FILE in
	*.zip)     zip -r "$FILE" "${FILE%????}"    ;;
	*.rar)     rar "$FILE" "${FILE%????}"       ;;
	*.7z)      7z a -mx9 "$FILE" "${FILE%???}" ;;
	*.tar.lz4) tar cvf - "${FILE%????????}" | lz4 > "$FILE" ;;
	*.lz4)     lz4 -9 "${FILE%????}" "$FILE"    ;;
	*.tar.bz2) tar cjf "$FILE" "${FILE%????????}"  ;;
	*.tar.gz)  tar czf "$FILE" "${FILE%???????}"  ;;
	*.tgz)     tar czf "$FILE" "${FILE%????}"   ;;
	*.tar.xz)  tar cJf "$FILE" "${FILE%???????}"  ;;
	*.xz)      xz -z -c -9  "${FILE%???}" > "$FILE" ;;
	*)         echo "Filetype not recognized" ;;
	esac
}

ex() {
	if [ ! -f "$1" ]; then
		echo "'$1' is not a valid file"
		return
	fi
	case "$1" in
	*.tar.bz2)   tar xjf "$1"   ;;
	*.tar.gz)    tar xzf "$1"   ;;
	*.bz2)       bunzip2 "$1"   ;;
	*.rar)       unrar x "$1"   ;;
	*.gz)        gunzip "$1"    ;;
	*.tar)       tar xf "$1"    ;;
	*.tbz2)      tar xjf "$1"   ;;
	*.tgz)       tar xzf "$1"   ;;
	*.zip)       unzip -d "${1%????}" "$1"     ;;
	*.Z)         uncompress "$1";;
	*.7z)        7za x "$1"     ;;
	*.iso)       7z x "$1"      ;;
	*.deb)       ar x "$1"      ;;
	*.tar.xz)    tar xf "$1"    ;;
	*.xz)        xz -d "$1"     ;;
	*.tar.zst)   unzstd "$1"    ;;
	*.tar.lz4)   lz4 -d "$1" -c | tar xvf - ;;
	*.lz4)       lz4 -d "$1"    ;;
	*)           echo "'$1' cannot be extracted via ex()" ;;
	esac
}

cflg() {
	export CFLAGS="$1"
	export KCFLAGS="$CFLAGS"
	export CXXFLAGS="$CFLAGS"
	export KCPPFLAGS="$CFLAGS"
}

o3() {
	cflg "-O3 -pipe -mtune=native -march=native"
}

o0() {
	cflg "-O0"
}

o2() {
	cflg "-O2"
}

os() {
	cflg "-Os"
}

d3() {
	cflg "-O3 -pipe -mtune=native -march=native -g"
}

d2() {
	cflg "-O2 -g"
}

d0() {
	cflg "-O0 -g"
}

klecinst() {
	pass=$2
	if [ ! "$2" ]; then pass="a"; fi
	compr klec.tar.gz && passh -p "$pass" scp klec.tar.gz "$1:~/"
	exec=""
	if [ "$3" ]; then
		exec="$exec echo -e '$3\n$3\n$3\n' | sudo -S -k passwd root &&"
		exec="$exec echo -e '$3\n$3\n$3\n' | sudo -S -k passwd \$(id -nu) &&"
		exec="$exec echo '$3' | sudo -S -k sudo sed -i 's/^#\?PermitRootLogin .*/PermitRootLogin yes/' /etc/ssh/sshd_config &&"
		exec="$exec echo '$3' | sudo -S -k sudo service sshd restart &&"
	fi
	exec="$exec rm -rf ~/klec && tar -xf ~/klec.tar.gz &&"
	exec="$exec cd ~/klec && sh install.sh"
	passh -p "$pass" ssh "$1" "$exec"
}

[ -f "$HOME/links" ] && fd > /dev/null 2>&1
[ -f "$HOME/.lrc" ] && . "$HOME/.lrc"
unset ENVSET
