#!/bin/sh
export EXINIT="se noled|tp Oo{
}kA
	|tp 1G2\"qY2j\"Qy$|tp oA {jo}koa|tp 0\"wy$|tp oa()i|tp 0\"ey$|tp oa\"\"i|tp 0\"ry$|tp oI/*A*/|tp 0\"aY|tp oi/*A*/|tp 0\"sy$|tp o/\/\*
2x/\*\/
2x|tp 02k2\"dY2j\"Dy$|tp o>\%<<\$\%<<|tp 0\"xy$|tp o:\!cp \% \%_\\|w\\|\!git diff --no-index \%_ \%|tp 0\"fy$|tp o:ac  \\|tp i\\|u\\|ac3ls|tp 0\"cy$|inc (^[\!.git]+[^\\/]+$)|tp 50u|se led"

export KISS_SU=su
export KISS_PATH=
KISS_PATH="$HOME/kiss/no-updates"
KISS_PATH="${KISS_PATH}:$HOME/kiss/repo/core"
KISS_PATH="${KISS_PATH}:$HOME/kiss/kiss-xorg/extra"
KISS_PATH="${KISS_PATH}:$HOME/kiss/kiss-xorg/xorg"
KISS_PATH="${KISS_PATH}:$HOME/kiss/kiss-xorg/community"
KISS_PATH="${KISS_PATH}:$HOME/kiss/repo/extra"
KISS_PATH="${KISS_PATH}:$HOME/kiss/community/community"
KISS_PATH="${KISS_PATH}:$HOME/kiss/repo-vulkan"
export CHROME_FLAGS="--no-sandbox"
export XDG_RUNTIME_DIR=/tmp
export PATH=/root/klec/shell:$PATH
export EDITOR=vi
export HOST_PS1="\[\e[1;33m\]$(printf '%.1s%s' "$HOSTNAME" "${HOSTNAME#${HOSTNAME%?}}")\[\e[m\]"
export PS1="\[\e[1;31m\]\A\[\e[m\]$HOST_PS1\[\e[1;32m\]\w\[\e[m\] "
export CFLAGS="-O2"
export KCFLAGS="$CFLAGS"
export CXXFLAGS="$CFLAGS"
export KCPPFLAGS="$CFLAGS"
export NCORES="$(grep "^processor" /proc/cpuinfo | wc -l)"
export MAKEFLAGS="-j$NCORES"
export PREFIX=/usr
export DISPLAY=:2
export FDMAXLEN=0

# git
alias g='git'
alias ga='git add'
alias gal='git add .'
alias gap='git add --patch'
alias gb='git branch'
alias gc='git commit'
alias gcm='git commit -m'
alias gcms='git commit -S -m'
alias gco='git checkout'
alias gcom='git checkout main || git checkout master'
alias gd='git diff'
alias gds='git diff --staged'
alias gf='git fetch'
alias gl='git log --graph --oneline'
alias glg="git log --all --graph --decorate --stat"
alias glf='git log --follow --'
alias gp='git push'
alias gpf='git push --force'
alias gpl='git pull'
alias grb='git rebase'
alias grc='git rebase --continue'
alias gs='git status'
alias ge='git config user.email'
alias gsh='git stash'
alias grh='git reset --hard'
alias gr='git restore'
alias grs='git reset'
alias gcl='git clean'
alias gcls='git clean -fxd'
alias gf='git fetch'
alias gfv='git fetch -v'
alias gurl='git remote get-url --push origin'
alias gpurl='git remote set-url --push origin'
alias gurls='git remote get-url --all origin'
alias gra='git remote add'
alias gcp='g cherry-pick'
alias gcn='g cherry-pick --continue'
alias gca='g cherry-pick --abort'
alias gfp='git format-patch'
alias gam='git am'
grsr() { git reset $1 && rm $1; }
gct() { git checkout tags/$1; }
gfork() { git remote add fork "$1" && git fetch fork && git merge fork/master; }
grt() { git reset HEAD~"$1"; }
gcop() {
	first="$1"; shift;
	for var in "$@"
	do
		git checkout $first -- $var
	done
}
gcr() {
	git clone --recursive "$@"
	if [ $# -eq 1 ]; then
		cd $(echo "$1" | sed 's/.*\///' | sed 's/.git$//')
	fi
}

# void linux
alias xq='xbps-query -R -s'
alias xi='xbps-install'
alias xr='xbps-remove'

# arch linux
alias pac='pacman'
alias pc='rm /var/lib/pacman/db.lck'
alias mpkg='makepkg -si --skippgpcheck --skipinteg --skipchecksums'

# kiss linux
alias k='kiss'
alias kc='kiss-chroot'
alias kd='export KISS_DEBUG=1'
alias kdu='unset KISS_DEBUG'
alias kds='export KISS_STRIP=0'
alias km='kiss manifest'
alias krv='kiss revdepends'
alias kdp='kiss depends'
krepo() { export KISS_PATH="$KISS_PATH:$HOME/kiss/$*"; }
kow() { kiss owns /bin/$1; }
kpc() {
	dirs=$(ls $HOME/.cache/kiss/proc/*/build/)
	echo "$dirs" | tr '\n' ' ' | sed "s/  /\n/g" ; echo
	if [ "$2" ]; then
		cd $HOME/.cache/kiss/proc/$2*/build/$1*;
	else
		cd $HOME/.cache/kiss/proc/*/build/$1*;
	fi
}
knu() { mkdir -p $HOME/kiss/no-updates && cp -r /var/db/kiss/installed/"$1" $HOME/kiss/no-updates; }
kru() { rm -Rf $HOME/kiss/no-updates/"$1"; }
ki() { export KISS_PROMPT=0 && kiss b "$1" && kiss i "$1" && unset KISS_PROMPT; }
kcd() { cd $(kiss search "$1"*) && echo "$(kiss search "$1"*)"; }
krs() { export KISS_FORCE=1; for file in $@; do kiss r "$file"; done; unset KISS_FORCE; }
kcmv() { git commit -m "$(basename $(pwd)): $* $(cat version)"; }
kcmvs() { git commit -S -m "$(basename $(pwd)): $* $(cat version)"; }
kcm() { git commit -m "$(basename $(pwd)): $*"; }
kcms() { git commit -S -m "$(basename $(pwd)): $*"; }

# make
alias m='make'
alias mi='make install'
alias mc='make clean'
alias mu='make uninstall'

# random progs
alias reset='stty sane && reset'
alias re='grep --color=auto'
alias ls='ls --color=auto'
alias l='ls -glhaS'
alias i='vi'
alias df='df -h'
alias cp='cp -r'
alias rm='rm -rf'
alias s='su -l'
alias feh='feh --title %f___[%wX%h]_[%u/%l] -p'
alias d='gdb --args'
alias c='cd ..'
alias fnd='find . -name'
alias thw='hwclock --systohc'
alias lsnet='netstat -tulpn'
alias va='valgrind --log-file=valog'
alias cgr='valgrind --tool=callgrind'
alias tmd='mount -o size=256G,noatime -t tmpfs tmpfs'
alias b='./build.sh && ./build.sh install'
alias rc='source $HOME/.rc'
alias xo='xclip -selection clipboard'
alias xp='xclip -o'
alias wp='waypaste'
alias wo='waycopy'
alias gmk='grub-mkconfig -o /boot/grub/grub.cfg'
alias j='jobs'
alias q='fg'
alias 1q='fg %1'
alias 2q='fg %2'
alias 3q='fg %3'
alias 4q='fg %4'
alias 5q='fg %5'
alias me='ssh kyryl.me'

# llama.cpp stuff
llmi() { main --log-disable --keep -1 -s -1 -t $((NCORES-1)) --mlock --prompt-cache "$1.cache" --color -c 4096 --temp 0.7 -f $PWD/prompt.txt -r "" -r "### Instruction:" --in-prefix "
### Instruction:
" --in-suffix "### Response:
" --multiline-input -i $LLM_ARGS -m "$@"; }
llml() { main --log-disable --keep -1 -s -1 -t $((NCORES-1)) --mlock --prompt-cache "$1.cache" --color -c 4096 --temp 0.7 -f $PWD/prompt.txt -r "" -r "<|im_start|>user" --in-prefix "
<|im_start|>user
" --in-suffix "<|im_end|>
<|im_start|>assistant
" --multiline-input -i $LLM_ARGS -m "$@"; }
llmp() { main --log-disable --keep -1 -s -1 -t $((NCORES-1)) --mlock -c 4096 --temp 0.7 $LLM_ARGS -p "Below is an instruction that describes a task. Write a response that appropriately completes the request.
### Instruction:
$1
### Response:
" -m "$2"; }
llmml() { main --log-disable --keep -1 -s -1 -t $((NCORES-1)) --mlock -c 4096 --temp 0.7 $LLM_ARGS -p "<|im_start|>system
Answer to the best of your ability<|im_end|>
<|im_start|>user
$1<|im_end|>
<|im_start|>assistant
" -m "$2"; }

neq() { echo "-$(seq -s ' -' $@)"; }
nopw() { [ "$1" ] && passwd -d "$@" && return; passwd -d $(id -nu); }
path() { export PATH="$@:"$PATH; }
crop() { convert "$1" -crop "$2" "_$1"; }
imgs() { convert -strip -quality "$1" "$2" "_$2"; }
ntmount() { ntfs-3g -o uid=1000,gid=1000,dmask=22,fmask=133 "$@"; }
sof() { scp -r "$1" root@kyryl.me:"$2"; }
sif() { scp -r root@kyryl.me:"$@"; }
scat() { cat ~/.ssh/id_rsa.pub | ssh "$1" 'cat >> .ssh/authorized_keys'; }
e() { echo "$@"; }
p() { printf "$@"; }
inf() { IFS="
"; for p in $1; do eval "$2 \$p $3"; done }
sd() {
	reg=".*$1[^\/]*$"; if [ "$2" ]; then reg=".*$1"; fi;
	dir=$(find -type d -regex $reg); echo "$dir"  | grep -n -E . && read i;
	if [ -z "$i" ]; then i=1; fi;
	cd "$(echo "$dir" | sed -n "$i"p)"
}
fup() { curl -F"file=@$@" https://0x0.st/; }
loc() { find . -name "$@" | xargs wc -l; }
r() { grep -n -r "$@" . ; }
cdls() {
	export PS1="\[\e[1;31m\]\A\[\e[m\]$HOST_PS1\[\e[1;32m\]\w\[\e[m\] "
	\cd "$@" && l;
}
cdlsn() {
	export PS1="\[\e[1;31m\]\A\[\e[m\]$HOST_PS1\[\e[1;35m\]$1\[\e[1;32m\]\w\[\e[m\] "
	\cd "$2" && l;
}
fullpath() {
	f=$@;
	if [ -d "$f" ]; then
		base="";
		dir="$f";
	else
		base="/$(basename "$f")";
		dir=$(dirname "$f");
	fi;
	dir=$(\cd "$dir" && pwd);
	echo "$dir$base"
}
replace() {
	tmp="$1_"
	head -n "$(($2 - 1))" "$1" > "$tmp"
	echo "$3" >> "$tmp"
	tail -n "+$(($2 + 1))" "$1" >> "$tmp"
	mv "$tmp" "$1"
}
alias cd='cdls'
alias v='cd'
alias vv='cd -'
fd() {
	sarg=""
	if [ "$1" ]; then
		case $1 in
			''|*[!0-9-]*)
				sarg="$(fullpath $1)"
			;;
			*)
				for arg in "$@"; do
					if [ "$arg" -lt 0 ]; then
						cnt=${arg#-}
						echo "$(sed "${cnt}s/.*//" "$HOME/links")" > "$HOME/links"
					else
						sarg="$(pwd)"
					fi
				done
				if [ "$1" -lt 0 ]; then fd; return; fi
			;;
		esac
	fi
	[ $# -ge 1 ] && shift;
	cnt=0
	while IFS= read -r line || [[ -n "$line" ]]; do
		cnt=$((cnt+1))
		if [ "$sarg" ]; then
			if [ -z "$line" ]; then
				line="$sarg | $@"
				replace "$HOME/links" $cnt "$line" && fd
				return
			fi
			continue
		fi
		[ -z "$line" ] && continue
		p=${line%% | *}
		cmd="${line#"$p | "}"
		eval "export c${cnt}=$p"
		eval "var=\"$cmd\""
		alias "$cnt"="$var"
		var="$cnt $p"
		[[ ${#var} -gt $FDMAXLEN ]] && FDMAXLEN="${#var}";
		printf "$cnt $p"
		x=$(($FDMAXLEN - ${#var}))
		while [ $x -gt 0 ];
		do
			printf " "
			x=$(($x-1))
		done
		printf " | %s\n" "$cmd"

	done < "$HOME/links"
	export FDMAXLEN
	[ "$sarg" ] && echo "$sarg | $@" >> "$HOME/links" && fd;
}
alias f='fd'
ff() { arg=$@; [ ! "$arg" ] && arg="."; if [ -d "$arg" ]; then fd "$arg" cdlsn \$cnt \$p; else fd "$arg" vi \$p; fi }
frm() { fd $(neq "$@"); }
ii() { [ "$1" ] && if ! grep -q -e "$1" "$HOME/links"; then fd "$1" vi \$p &> /dev/null; fi; vi "$@"; }

compr() {
	FILE=$1
	shift
	case $FILE in
	*.tar.bz2) tar cjf $FILE "${FILE%%.*}"  ;;
	*.tar.gz)  tar czf $FILE "${FILE%%.*}"  ;;
	*.tgz)     tar czf $FILE "${FILE%.*}"  ;;
	*.zip)     zip $FILE "${FILE%.*}"      ;;
	*.rar)     rar $FILE "${FILE%.*}"      ;;
	*)         echo "Filetype not recognized" ;;
	esac
}

ex() {
	if [ ! -f $1 ]; then
		echo "'$1' is not a valid file"
		return
	fi
	case $1 in
	*.tar.bz2)   tar xjf $1   ;;
	*.tar.gz)    tar xzf $1   ;;
	*.bz2)       bunzip2 $1   ;;
	*.rar)       unrar x $1   ;;
	*.gz)        gunzip $1    ;;
	*.tar)       tar xf $1    ;;
	*.tbz2)      tar xjf $1   ;;
	*.tgz)       tar xzf $1   ;;
	*.zip)       unzip $1     ;;
	*.Z)         uncompress $1;;
	*.7z)        7za e x $1   ;;
	*.deb)       ar x $1      ;;
	*.tar.xz)    tar xf $1    ;;
	*.tar.zst)   unzstd $1    ;;
	*)           echo "'$1' cannot be extracted via ex()" ;;
	esac
}

cflg() {
	export CFLAGS="$1"
	export KCFLAGS="$CFLAGS"
	export CXXFLAGS="$CFLAGS"
	export KCPPFLAGS="$CFLAGS"
}

o3() {
	cflg "-O3 -pipe -mtune=native -march=native"
}

o0() {
	cflg "-O0"
}

d2() {
	cflg "-O2 -g"
}

d0() {
	cflg "-O0 -g"
}

klecinst() {
	pass=$2
	if [ ! "$2" ]; then pass="a"; fi
	compr klec.tar.gz && passh -p $pass scp klec.tar.gz "$1:~/"
	exec=""
	if [ "$3" ]; then
		exec="$exec echo -e '$3\n$3\n$3\n' | sudo -S -k passwd root &&"
		exec="$exec echo -e '$3\n$3\n$3\n' | sudo -S -k passwd \$(id -nu) &&"
		exec="$exec echo '$3' | sudo -S -k sudo sed -i 's/^#\?PermitRootLogin .*/PermitRootLogin yes/' /etc/ssh/sshd_config &&"
		exec="$exec echo '$3' | sudo -S -k sudo service sshd restart &&"
	fi
	exec="$exec tar -xf ~/klec.tar.gz &&"
	exec="$exec cd ~/klec && sh install.sh &&"
	exec="$exec echo \"source ~/.rc\" > ~/.profile"
	passh -p $pass ssh $1 $exec
}

[ -f "$HOME/links" ] && fd &> /dev/null;
[ -f "$HOME/.lrc" ] && source $HOME/.lrc;
